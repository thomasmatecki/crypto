import base64
import os
from cryptography.hazmat.primitives import hashes, padding, ciphers
import struct
import time

from cryptography.hazmat.backends import default_backend


class InvalidToken(Exception):
  pass


def num(byte_it):
  """Convert bytes array to a number(note endian-ness!)"""
  num = 0x00
  for i, b in enumerate(bytearray(byte_it[::-1])):
    num = num | (b << 8 * i)

  return num


def byteblock(num):
  return bytes(bytearray(map(lambda i: (num >> i * 8) & 0xff, range(15, -1, -1))))


def block_xor(b0, b1):
  return byteblock(num(b0) ^ num(b1))


def split_into_blocks(msg, l):
  while msg:
    yield msg[:l]
    msg = msg[l:]


# From  RFC 4493, AES-CMAC  Constants:
#   const_Zero is 0x00000000000000000000000000000000
#   const_Rb   is 0x00000000000000000000000000000087

CONST_RB = byteblock(num([0x87]))
CONST_ZERO = byteblock(0)


class Fernet(object):
  """
   A Fernet 0x91 ciphertext is the base64url encoding of the concatenation of the following fields:

    Version || Timestamp || IV || Ciphertext || MAC

    - Version, 8 bits
    - Timestamp, 64 bits
    - IV, 128 bits
    - AES-CTR ciphertext, variable length, multiple of 8 bits (byte-aligned plaintexts only)
    - CMAC tag, 128 bits
  """

  def __init__(self, key, backend=None):
    if backend is None:
      backend = default_backend()

    key = base64.urlsafe_b64decode(key)
    if len(key) != 32:
      raise ValueError(
        "Fernet key must be 32 url-safe base64-encoded bytes."
      )

    self._signing_key = key[:16]
    self._encryption_key = key[16:]
    self._backend = backend

  def _prf(self, key):
    """
    Return an AES block cipher function for the given key.

    :param key:
    :return:
    """
    cipher = ciphers.Cipher(ciphers.algorithms.AES(key),
                            ciphers.modes.ECB(),
                            self._backend)

    def _invoke(data):
      encryptor = cipher.encryptor()
      return encryptor.update(data) + encryptor.finalize()

    return _invoke

  def _ctr_blocks(self, iv0, data):
    """
    Generator for AES block cipher - counter mode on `data` for the given
    initialization vector. Each block of the message is XOR'ed with the
    bytes of the AES PRF applied to `blk_vec`, which is the IV incremented
    by 1 for each block. Note the least significant digit of `blk_vec` is
    the highest index in the bytearry(big-endian).

    :param iv0:
    :param data:
    :return:
    """
    assert len(iv0) == 16

    encrypt_prf = self._prf(self._encryption_key)

    ivn = num(iv0)

    while data:
      blk_vec = byteblock(ivn)
      cvx = encrypt_prf(blk_vec)

      yield bytearray(ord(m) ^ ord(c) for m, c in zip(data[:16], cvx))

      data = data[16:]
      ivn += 1

  def _cmac(self, data):
    """
    AES-CMAC as defined in RFC 4493. The core of AES-CMAC is the basic CBC-MAC.

    To authenticate a message, the CBC-MAC is applied.  There are two cases
    in CMAC. If the size of the input message block is equal to a positive
    multiple of the block size, the last block is XOR'ed with K1 before
    processing.  Otherwise, the last block is be padded with 10^i and
    XOR'ed with K2,

    K1 and K2 are subkeys generated by applying the PRF to `00000....`

    :param data:
    :return:
    """

    signing_prf = self._prf(self._signing_key)

    # Generate the subkeys k1 and k2,

    # Step 1
    # L := AES-128(K, const_Zero);
    ls = signing_prf(CONST_ZERO)
    ln = num(ls)

    # Step 2
    #   if MSB(L) is equal to 0: K1 := L << 1;
    #   else                     K1 := (L << 1) XOR const_Rb;
    k1 = byteblock(ln << 1 if ln >> 127 == 0 else (ln << 1) ^ num(CONST_RB))

    # Step 3
    #   if MSB(K1) is equal to 0: K2 := K1 << 1;
    #   else:                     K2 := (K1 << 1) XOR const_Rb;
    k1n = num(k1)
    k2 = byteblock(k1n << 1 if k1n >> 127 == 0 else (k1n << 1) ^ num(CONST_RB))

    blocks = list(split_into_blocks(data, 16))

    # Tweak the last block by XOR'ing with either subkey k1 or k2.
    # If the last block is not 16 bytes, pad with the bit-string
    # 10^i to adjust the length of the last block up to the block
    # length.
    last_block_len = len(blocks[-1])

    if last_block_len < 16:
      last_block = block_xor(
        blocks[-1] + '\x80' + '\x00' * (15 - last_block_len),
        k2)
    else:
      last_block = block_xor(blocks[-1], k1)

    # Replace the last block with the tweaked block
    blocks = blocks[:-1] + [last_block]

    # Perform the AES-CBC algorithm main loop
    tag = reduce(
      lambda block, prev: signing_prf(block_xor(block, prev)),
      blocks,
      CONST_ZERO)

    return tag

  @classmethod
  def generate_key(cls):
    return base64.urlsafe_b64encode(os.urandom(32))

  def encrypt(self, data, iv0=None):
    """
    Create a 0x91 Fernet ciphertext (as described above), for a given plaintext

    :param data:
    :return:
    """
    # For testing, an initialization vector can be provided
    if not iv0:
      iv0 = os.urandom(16)

    blocks = tuple(str(block) for block in self._ctr_blocks(iv0, data))

    ctx = "%s" * len(blocks) % blocks

    timestamp = struct.pack(">Q", int(time.time()))

    mac = self._cmac(b"\x91" + timestamp + iv0 + ctx)

    output = b"\x91" + timestamp + iv0 + ctx + mac

    return base64.urlsafe_b64encode(output)

  def decrypt(self, token, timetolive=None):
    """
    Validate and decrypt a 0x91 Fernet ciphertext and return the original message.

    :param token:
    :param timetolive:
    :param kwargs:
    :return:
    """

    decoded = base64.urlsafe_b64decode(token)

    # Ensure the cipher text is long enough to contain a version,
    # timestamp, initialization vector, and CMAC tag.
    min_length = 1 + 8 + 16 + 16
    if len(decoded) < min_length:
      raise ValueError('The ciphertext must exceed {} bytes(too short).'.format(min_length))

    # Disassemble the message.
    version, timestamp, iv0, ctx, token_mac = decoded[0], decoded[1:9], decoded[9:25], decoded[25:-16], decoded[-16:]

    # Ensure version is correct
    if version != '\x91':
      raise InvalidToken("Invalid version token: {}".format(token[0]))

    # Verify MAC is correct
    auth_mac = self._cmac(b"\x91" + timestamp + iv0 + ctx)
    if auth_mac != token_mac:
      raise InvalidToken("Message authentication code is invalid")

    # Verify timestamp has not expired
    msg_time = struct.unpack(">Q", timestamp)[0]

    curr_time = time.time()

    if timetolive and msg_time + timetolive < curr_time:
      raise InvalidToken("Timestamp {} exceeds time to live {}".format(msg_time, timetolive))

    # Perform AES-CTR decryption
    blocks = tuple(str(block) for block in self._ctr_blocks(iv0, ctx))
    msg = "%s" * len(blocks) % blocks

    return msg
